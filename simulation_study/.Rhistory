solve(spt_tmp$Sigma)
spt_tmp <- calculate_spatial_params(full_simdata, n = n, cube.root.transform = cube.root.transform, plot.var = FALSE)
solve(spt_tmp$Sigma)
spt_tmp <- calculate_spatial_params(full_simdata, n = n, cube.root.transform = cube.root.transform, plot.var = FALSE)
solve(spt_tmp$Sigma)
solve(spt_tmp$Sigma)
str(spt_tmp$Sigma)
solve(spt_tmp$Sigma, tol = 1e-22)
spt_tmp <- calculate_spatial_params(full_simdata, n = n, cube.root.transform = cube.root.transform, plot.var = FALSE)
solve(spt_tmp$Sigma, tol = 1e-22)
S_noobs_inv <- solve(spt_tmp$Sigma, tol = 1e-22)
dim(S_noobs_inv)
S_obs_inv <- solve(spt_tmp$Sigma, tol = 1e-22)
dim(S_obs_inv)
S_noobs_tr <- t(spt_tmp$Sigma_noobs)
dim(S_noobs_tr)
zhat <- S_noobs_tr %*% S_obs_inv %*% z
hist(zhat)
pnorm(zhat)
pz <- pnorm(zhat)
pz[which(pz==1)] <- 1-.Machine$double.eps
pz[which(pz==0)] <- .Machine$double.eps
hist(z)
Pi
spt_tmp$Pi
pz < spt_temp$Pi
pz < spt_tmp$Pi
pz[pz < spt_tmp$Pi]
hist(pz)
hist(zhat)
zigs <- qzig(u = pz, mu = spt_tmp$mu, beta = spt_temp$beta, epsilon = spt_temp$epsilon, Pi = spt_temp$Pi)
zigs <- qzig(u = pz, mu = spt_tmp$mu, beta = spt_tmp$beta, epsilon = spt_tmp$epsilon, Pi = spt_tmp$Pi)
zigs <- qzig(u = pz, mu = spt_tmp$mu, beta = spt_tmp$beta, epsilon = spt_tmp$epsilon, Pi = spt_tmp$Pi[1])
hist(z)
S_noobs_tr %*% S_obs_inv
tmp$train[1,c("x", "y")]; tmp$test[1,c("x", "y")]
t1 <- tmp$train[1,c("x", "y")]; t2 <- tmp$test[1,c("x", "y")]
?dist
euc_dist <- function(t1, t2) {
return(sqrt(sum((t1[1] - t2[1])^2 + (t1[2] - t2[2])^2)))
}
t1[1]
euc_dist(t1, t2)
H_noobs[1,1]
hist(z)
hist(z); mean(z)
hist(pzig(y = spt_tmp$Y, mu = spt_tmp$mu, beta = spt_tmp$beta, epsilon = spt_tmp$epsilon, Pi = spt_tmp$Pi))
hist(zigs)
zigs^3
hist(zigs^3)
hist(full_simdata$resp)
hist(tmp$train$resp)
spt_tmp$mu
spt_tmp$Pi
v <- function(alpha, beta) { output <- (alpha*beta)/((alpha+beta)^2*(alpha + beta + 1)) }
v(1, 1)
v <- function(alpha, beta) { output <- (alpha*beta)/((alpha+beta)^2*(alpha + beta + 1)); return(output)}
v(1, 1)
v(2, 4)
v(4, 4)
v(4, 7)
v(4, 1)
v(2, 1)
v(4, 1)
v(2, 2)
v(4, 2)
v(2, 4)
v(1, 5)
v(3, 5)
v(2, 4)
v(4, 4)
v(1, 10)
v(3, 10)
p <- function(theta, n) {output = (theta^-1)*(1 - theta)^(n-1); return(output)}
p(.5, 0)
p(.4, 0)
x = seq(1, 10, by = .001)
y = x^(-1)*(1 - x)^(-1)
plot(x, y)
y = x^(-1)*((1 - x)^(-1))
plot(x, y)
y = x^(-1)*(1 - x)^(9)
plot(x, y)
y = (x^(-1))*(1 - x)^(9)
plot(x, y)
y = x^(-1)*((1 - x)^(-1))
plot(x, y)
y
y[1]
x
.01^-1
(.01^-1)*(.99)^-1
(.01^-1)*((.99)^-1)
hist(zigs)
z
hist(z)
qqnorm(z)
qqnorm(z)
qqline(z)
qqnorm(z)
hist(spt_tmp$Y)
hist(z)
hist(pzig(y = spt_tmp$Y, mu = spt_tmp$mu, beta = spt_tmp$beta, epsilon = spt_tmp$epsilon, Pi = spt_tmp$Pi))
?require
library(sp)
head(full_simdata)
class(full_simdata)
coordinates(full_simdata) <- ~x+y
class(full_simdata)
head(full_simdata)
lzn.vgm <- variogram(resp ~ 1, full_simdata)
lzn.fit <- fit.variogram(lzn.vgm, vgm("Gau"))
plot(lzn.vgm, lzn.fit)
colnames(full_simdata)
colnames(full_simdata@data)
c("a", "b", "c")
"a" %in% c("a", "b", "c")
c("a", "b") %in% c("a", "b", "c")
c("a") %in% c("a", "b", "c") && c("b") %in% c("a", "b", "c")
c("a") %in% c("a", "b", "c") & c("b") %in% c("a", "b", "c")
calculate_spatial_params <- function(full_simdata, n = 300, cube.root.transform = TRUE, plot.var = FALSE) {
#' Calculates Method of Moments estimates for Gamma model and the spatial covariance parameters for ordinary kriging
#' For use with the simulated datasets - no covariate information used here
tmp <- split_data(full_simdata, n = 300, cube.root.transform = TRUE)
H <- as.matrix(dist(tmp$train[,c("x", "y")]))
# Use method of moment estimator for gamma distribution
mu <- mean(tmp$train$resp[-tmp$zeros])
beta <- var(tmp$train$resp[-tmp$zeros])/mu
mu <- rep(mu, times=nrow(tmp$train))
#Calculate covariance parameters using variogram
emp_var <- variogram(resp~1,
loc=~x+y,
data = tmp$train)
v_fit <- tryCatch({
fit.variogram(emp_var,
vgm("Gau"))
}, warning = function(war) {
warning("Variogram did not converge.")
stop("Variogram did not converge.")
}, message = function(mes) {
message("Hmm something weird.")
})
if (plot.var) {
plot(emp_var,v_fit)
}
alphaN<-v_fit$psill[2]/sum(v_fit$psill) # nugget parameter
alphaR<-v_fit$range[2] # decay parameter
#Calculate spatial correlation matrix w. exponential form for observed points!
Sigma_obs<-alphaN*exp(-(H/alphaR)^2)
diag(Sigma)<-1
#Calculate spatial correlation matrix for observed/unobserved points!
H_noobs <- as.matrix(rdist(tmp$train[,c("x", "y")], tmp$test[,c("x", "y")]))
Sigma_noobs <- alphaN*exp(-(H_noobs/alphaR)^2)
output <- list(
Y = tmp$train$resp,
Sigma = Sigma_obs,
Sigma_noobs = Sigma_noobs,
alphaN = alphaN,
alphaR = alphaR,
epsilon = tmp$epsilon,
mu = mu,
beta = beta,
Pi = tmp$Pi,
test = tmp$test,
train = tmp$train
)
return(output)
}
full_simdata <- data.frame(
x = dat$x,
y = dat$y,
resp = simdata[2,]
)
spt_tmp <- calculate_spatial_params(full_simdata, n = n, cube.root.transform = cube.root.transform, plot.var = FALSE)
spt_tmp$train
training_data <- spt_tmp$train
test_points <- spt_tmp$test
z <- qnorm(pzig(y = spt_tmp$Y, mu = spt_tmp$mu, beta = spt_tmp$beta, epsilon = spt_tmp$epsilon, Pi = spt_tmp$Pi))
hist(z)
spt_tmp$beta
spt_tmp$mu
spt_tmp$epsilon
training_data$z <- z
head(test_points)
test_points <- test_points[,c("x", "y")]
head(test_points)
coordinates(training_data) <- ~x+y
coordinates(test_points) <- ~x+y
z.vgm <- variogram(z ~ 1, training_data)
tryCatch({
z.fit <- fit.variogram(z.vgm, vgm("Gau"))
}, warning = function(war) {
stop("Variogram did not converge.")
})
plot(z.vgm, z.fit)
z.fit <- fit.variogram(z.vgm, vgm("Exp"))
plot(z.vgm, z.fit)
z.fit <- fit.variogram(z.vgm, vgm("Sph"))
plot(z.vgm, z.fit)
z.fit <- fit.variogram(z.vgm, vgm("Gau"))
plot(z.vgm, z.fit)
ok_model <- krige(z ~ 1, training_data, test_points, model = z.fit)
suppressMessages(ok_model <- krige(z ~ 1, trainig_data, test_points, model = z.fit))
suppressMessages(ok_model <- krige(z ~ 1, training_data, test_points, model = z.fit))
invisible(ok_model <- krige(z ~ 1, training_data, test_points, model = z.fit))
View(ok_model)
ok_model$var1.pred
yhat <- ok_model$var1.pred
hist(y_hat)
yhat <- ok_model$var1.pred
hist(yhat)
hist(z)
pz <- pnorm(yhat)
hist(pz)
hist(yhat)
hist(pz)
hist(yhat)
hist(pz)
pz[which(pz==1)] <- 1-.Machine$double.eps
pz[which(pz==0)] <- .Machine$double.eps
zigs <- qzig(u = pz, mu = spt_tmp$mu, beta = spt_tmp$beta, epsilon = spt_tmp$epsilon, Pi = spt_tmp$Pi[1])
hist(zigs)
plot(spt_tmp$test$resp, zigs)
ord_kriging <- function(training_data, test_points) {
if (!("x" %in% colnames(training_data) && "y" %in% colnames(training_data))){
stop("Need to specify coordinates using x and y in training set")
}
if (!("x" %in% colnames(test_points) && "y" %in% colnames(test_points))){
stop("Need to specify coordinates using x and y in test set")
}
test_points <- test_points[,c("x", "y")]
coordinates(training_data) <- ~x+y
coordinates(test_points) <- ~x+y
resp.vgm <- variogram(resp ~ 1, training_data)
tryCatch({
resp.fit <- fit.variogram(z.vgm, vgm("Gau"))
}, warning = function(war) {
stop("Variogram did not converge.")
})
tryCatch({
invisible(ok_model <- krige(resp ~ 1, training_data, test_points, model = resp.fit))
}, warning = function(war) {
stop("Ordinary Kriging not successful.")
})
return(ok_model)
}
training_data <- spt_tmp$train
test_points <- spt_tmp$test
ok <- ord_krigin(training_data, test_points)
ok <- ord_kriging(training_data, test_points)
ok$var1.pred
head(training_data)
hist(training_data)
hist(training_data$resp)
epsilon
spt_tmp$epsilon
ok$var1.pred[ok$var1.pred < spt_tmp$epsilon]
ok$var1.pred[ok$var1.pred < spt_tmp$epsilon] <- 0
ok$var1.pred^3
hist(ok$var1.pred^3)
backtransform <- function(preds, epsilon) {
preds[preds < epsilon] <- 0
return(preds^3)
}
ok <- ord_kriging(training_data, test_points)
yhat <- backtransform(ok$var1.pred, spt_tmp$epsilon)
hist(yhat)
plot(spt_tmp$test$resp, yhat)
demo(meuse, echo=FALSE)
######################################################################
# Spatial prediction of a 2D continuous variable using buffer distance
######################################################################
meuse["zinc"]
meuse.grid[1]
library(raster)
grid.dist0 <- GSIF::buffer.dist(training_data, test_points, as.factor(1:nrow(training_data)))
library(GSIF)
grid.dist0 <- GSIF::buffer.dist(training_data, test_points, as.factor(1:nrow(training_data)))
test_points <- test_points[,c("x", "y")]
coordinates(training_data) <- ~x+y
coordinates(test_points) <- ~x+y
grid.dist0 <- GSIF::buffer.dist(training_data, test_points, as.factor(1:nrow(training_data)))
class(meuse.grid[1])
class(meuse["zinc"])
?buffer.dist
head(test_points)
training_data <- spt_tmp$train
test_points <- spt_tmp$test
test_points_spdf <- SpatialPixelsDataFrame(points = test_points[,c("X", "y")], data = test_points)
test_points_spdf <- SpatialPixelsDataFrame(points = test_points[,c("x", "y")], data = test_points)
head(test_points)
coordinates(training_data) <- ~x+y
coordinates(test_points) <- ~x+y
test_points_spdf <- SpatialPixelsDataFrame(points = test_points[,c("x", "y")], data = test_points$resp)
str(test_points)
test_points_spdf <- SpatialPixelsDataFrame(points = test_points@coords, data = test_points@data$resp)
gridded(test_points)
gridded(test_points) <- TRUE
?SpatialPoints]
?SpatialPoints
training_data <- spt_tmp$train
test_points <- spt_tmp$test
points <- SpatialPoints(test_points[,c("x", "y")], test_points[,c("resp")])
expand.grid(x = test_points$x, y = test_points$y)
points <- SpatialPoints(test_points[,c("x", "y")], test_points[,c("resp")])
?SpatialPOints
?SpatialPoints
points <- SpatialPointsDataFrame(test_points[,c("x", "y")], test_points[,c("resp")])
test_points[,c("resp")]
class(test_points[,c("resp")])
class(as.data.frame(test_points[,c("resp")]))
as.data.frame(test_points[,c("resp")])
points <- SpatialPointsDataFrame(test_points[,c("x", "y")], as.data.frame(test_points[,c("resp")]))
test_points_spdf <- SpatialPixelsDataFrame(points = points, data = points@data)
test_points_spdf <- SpatialPixelsDataFrame(points = points, data = points@data, tolerance = .5425)
grid.dist0 <- GSIF::buffer.dist(training_data, test_points, as.factor(1:nrow(training_data)))
?buffer.dist
coordinates(training_data) <- ~x+y
class(training_data)
class(points)
test_points_spdf <- SpatialPixelsDataFrame(points = points, data = points@data, tolerance = .5425)
test_points_spdf <- SpatialPixelsDataFrame(points = points, data = points@data, tolerance = .61)
tets_points_spdf
test_points_spdf
class(test_points_spdf)
grid.dist0 <- GSIF::buffer.dist(training_data, test_points_spdf, as.factor(1:nrow(training_data)))
names(grid.dist0)
str(grid.dist0)
dn0 <- paste(names(grid.dist0), collapse="+")
fm0 <- as.formula(paste("resp ~ ", dn0))
fm9
fm0
ov.resp <- over(training_data, grid.dist0)
ov.resp
str(ov.resp)
meuse@data$zinc
length(meuse@data$zinc)
rm.resp <- cbind(training_data$resp, ov.resp)
m.zinc <- ranger(fm0, rm.resp, quantreg=TRUE, num.trees=150)
library(rfsp)
library(ranger)
resp_ranger <- ranger(fm0, rm.resp, quantreg=TRUE, num.trees=150)
rm.resp <- cbind(training_data$resp, ov.resp)
resp_ranger <- ranger(fm0, rm.resp, quantreg=TRUE, num.trees=150)
str(rm.resp)
resp_ranger <- ranger(fm0, rm.resp, quantreg=TRUE, num.trees=150)
grid.dist0
grid.dist0$layer.1
str(test_points)
######################################################################
# Spatial prediction of a 2D continuous variable using buffer distance
######################################################################
grid.dist0 <- GSIF::buffer.dist(meuse["zinc"], meuse.grid[1], as.factor(1:nrow(meuse)))
grid.dist0
dn0 <- paste(names(grid.dist0), collapse="+")
fm0 <- as.formula(paste("zinc ~", dn0))
fm0
ov.zinc <- over(meuse["zinc"], grid.dist0) # over function creates an overlay object
ov.zinc
?over
meuse["zinc"]
grid.dist0
# meuse@data["zinc"]
meuse@data["zinc"]
# meuse@data["zinc"]
length(meuse@data["zinc"])
meuse@data
?meuse
training_data <- spt_tmp$train
test_points <- spt_tmp$test
points <- SpatialPointsDataFrame(training_data[,c("x", "y")], as.data.frame(training_data[,c("resp")]))
test_points_spdf <- SpatialPixelsDataFrame(points = points, data = points@data, tolerance = .61)
training_points_spdf <- SpatialPixelsDataFrame(points = points, data = points@data, tolerance = .61)
coordinates(training_data) <- ~x+y
grid.dist0 <- GSIF::buffer.dist(training_data, training_points_spdf, as.factor(1:nrow(training_data)))
dn0 <- paste(names(grid.dist0), collapse="+")
fm0 <- as.formula(paste("resp ~ ", dn0))
ov.resp <- over(training_data, grid.dist0)
rm.resp <- cbind(training_data$resp, ov.resp)
resp_ranger <- ranger(fm0, rm.resp, quantreg=TRUE, num.trees=150)
rm.resp <- cbind(training_data$resp, ov.resp)
str(ov.resp)
training_data$resp
str(training_data$resp)
rm.resp <- cbind(data.frame(resp = training_data$resp), ov.resp)
str(rm.resp)
resp_ranger <- ranger(fm0, rm.resp, quantreg=TRUE, num.trees=150)
resp_ranger
grid.dist0@data
resp.predict <- predict(resp_ranger, grid.dist0)
fm0
colnames(grid.dist0)
str(grid.dist0)
resp.predict <- predict(resp_ranger, grid.dist0@data)
resp.predict$predictions
hist(resp.predict$predictions)
hist(training_data$resp)
plot(training_data$resp, resp.predict$predictions)
?meuse.grid
meuse.grid[1]
meuse.grid[2]
meuse.grid[8]
meuse.grid[7]
meuse.grid[6]
meuse.grid[3]
meuse.grid[4]
ncol(meuse.grid)
resp_ranger
plot(training_data$resp, resp.predict$predictions)
"resp" %in% colnames(training_data)
colnames(training_data)
list()
x = list()
x$red = c(1, 2, 3)
x
meuse.grid
class(meuse.grid[1])
meuse.grid[1]
?SpatialPointsDataFrame
training_data <- spt_tmp$train
test_data <- spt_tmp$test
test_points <- SpatialPointsDataFrame(test_data[,c("x", "y")])
test_points <- SpatialPointsDataFrame(test_data[,c("x", "y")], as.data.frame(test_data[,c("resp")]))
test_points_spdf <- SpatialPixelsDataFrame(points = points, data = points@data, tolerance = .61)
test_points_spdf
coordinates(training_data) <- ~x+y
coordinates(training_data) <- ~x+y
# need to predict values at the test points?
class(training_data)
grid.dist0 <- GSIF::buffer.dist(training_data, test_points_spdf, as.factor(1:nrow(training_data)))
?buffer.dist
dn0 <- paste(names(grid.dist0), collapse="+")
fm0 <- as.formula(paste("resp ~ ", dn0))
ov.resp <- over(training_data, grid.dist0)
rm.resp <- cbind(data.frame(resp = training_data$resp), ov.resp)
summary(rm.resp)
rm.resp$layer.1
rm.resp$resp
resp_ranger <- ranger(fm0, rm.resp, quantreg=TRUE, num.trees=150)
resp_ranger
summary(rm.resp)
resp_ranger
resp.predict <- predict(resp_ranger, grid.dist0@data)
hist(resp.predict$predictions)
str(resp.predict)
grid.dist0@data
str(grid.dist0@data)
grid.dist0
plot(test_data$resp, resp.preditct$predictions)
plot(test_data$resp, resp.predict$predictions)
length(test_data$resp)
length(resp.predict$predictions)
test_points_spdf
test_points_spdf$`training_data[, c("resp")]`
str(test_points_spdf)
test_points_spdf <- SpatialPixelsDataFrame(points = points, data = points@data, tolerance = .61)
str(test_points_spdf)
test_data <- spt_tmp$test
test_points <- SpatialPointsDataFrame(test_data[,c("x", "y")], as.data.frame(test_data[,c("resp")]))
test_points_spdf <- SpatialPixelsDataFrame(points = points, data = points@data, tolerance = .61)
str(test_points_spdf)
test_points_spdf <- SpatialPixelsDataFrame(points = test_points, data = test_points@data, tolerance = .61)
test_points <- SpatialPointsDataFrame(test_data[,c("x", "y")], as.data.frame(test_data[,c("resp")]))
test_points_spdf <- SpatialPixelsDataFrame(points = test_points, data = test_points@data, tolerance = .61)
test_points <- SpatialPointsDataFrame(test_data[,c("x", "y")], as.data.frame(resp = test_data[,c("resp")]))
test_points_spdf <- SpatialPixelsDataFrame(points = test_points, data = test_points@data, tolerance = .61)
test_points <- SpatialPointsDataFrame(test_data[,c("x", "y")], as.data.frame(resp = test_data[,c("resp")]))
test_points <- SpatialPointsDataFrame(test_data[,c("x", "y")], data.frame(resp = test_data[,c("resp")]))
test_points_spdf <- SpatialPixelsDataFrame(points = test_points, data = test_points@data$resp, tolerance = .61)
class(test_points)
test_points_spdf <- SpatialPixelsDataFrame(points = test_points, data = test_points@data, tolerance = .61)
str(test_points_spdf)
test_points_spdf@coords
668+424
grid.dist0 <- GSIF::buffer.dist(training_data, test_points_spdf, as.factor(1:nrow(training_data)))
dn0 <- paste(names(grid.dist0), collapse="+")
fm0 <- as.formula(paste("resp ~ ", dn0))
ov.resp <- over(training_data, grid.dist0)
rm.resp <- cbind(data.frame(resp = training_data$resp), ov.resp)
summary(rm.resp)
resp_ranger <- ranger(fm0, rm.resp, quantreg=TRUE, num.trees=150)
coordinates(training_data) <- ~x+y
grid.dist0 <- GSIF::buffer.dist(training_data, training_points_spdf, as.factor(1:nrow(training_data)))
dn0 <- paste(names(grid.dist0), collapse="+")
fm0 <- as.formula(paste("resp ~ ", dn0))
ov.resp <- over(training_data, grid.dist0)
rm.resp <- cbind(data.frame(resp = training_data$resp), ov.resp)
resp_ranger <- ranger(fm0, rm.resp, quantreg=TRUE, num.trees=150)
resp_ranger
grid.dist1 <- GSIF::buffer.dist(training_data, test_points_spdf, as.factor(1:nrow(training_data)))
resp.predict <- predict(resp_ranger, grid.dist1@data)
hist(resp.predict$predictions)
plot(training_data$resp, resp.predict$predictions)
resp.predict$predictions
plot(test_data$resp, resp.predict$predictions)
spt_tmp$train$resp
hist(spt_tmp$train$resp)
:w
plot(test_data$resp, resp.predict$predictions)
hist(resp.predict$predictions)
grid.dist1@data
plot(test_data$resp, resp.predict$predictions)
hist(training_data$resp)
install.packages("foreach")
install.packages("doParallel")
?rdist
install.packages("roxygen")
install.packages("roxygen2")
simdata <- readRDS("../simulated_Y.rds")
getwd()
setwd("~/MS_Project/simulation_study/")
getwd()
